% SCRIPT TO VISUALISE POSITION, SPEED, AND LOCOMOTION THRESHOLD
%
% This script iterates through all processed sessions and creates a plot
% for each one. The plot displays X position, Y position, and speed over
% time. It also overlays the automatically calculated locomotion speed
% threshold as a horizontal line for validation.
%
% For sessions with centimeter data, a two-panel plot is created (px and cm).
% For sessions without, a single-panel plot (px) is created.

clear all;
close all; 

% --- 1. Define Root Path ---
data_root_path = 'C:\Users\abbim\OneDrive - University College London\Documents\MSc\ResearchProject\MATLAB\TetrodeAnalysis\RawBehaviouralAnalysis\PositionExtraction';

fprintf('=== STARTING VISUALISATION OF POSITION, SPEED, AND THRESHOLDS ===\n');

% --- 2. Set Up Directory and Start Loop ---
animal_folders = dir(data_root_path);
animal_folders = animal_folders([animal_folders.isdir] & ~ismember({animal_folders.name},{'.','..'}));

for j = 1:length(animal_folders)
    current_animal_path = fullfile(data_root_path, animal_folders(j).name);
    fprintf('\n--- Visualising Animal: %s ---\n', animal_folders(j).name);
    
    experiment_folders = dir(current_animal_path);
    experiment_folders = experiment_folders([experiment_folders.isdir] & ~ismember({experiment_folders.name},{'.','..'}));
    
    for i = 1:length(experiment_folders)
        session_name = experiment_folders(i).name;
        current_experiment_path = fullfile(current_animal_path, session_name);
        
        % --- Flexibly load the final data file ---
        if exist(fullfile(current_experiment_path, 'position_final_cm.mat'), 'file')
            final_file_to_load = fullfile(current_experiment_path, 'position_final_cm.mat');
        else
            final_file_to_load = fullfile(current_experiment_path, 'position_a_s_sc_inj_aligned.mat');
        end
        
        if exist(final_file_to_load, 'file')
            fprintf('  - Plotting session: %s\n', session_name);
            load(final_file_to_load, 'clean_position');
            
            % --- Call the plotting helper function ---
            plot_position_speed_with_threshold(clean_position, session_name);
        end
    end
end

fprintf('\n=== VISUALISATION SCRIPT COMPLETE ===\n');


%% ========================================================================
%  HELPER FUNCTION FOR PLOTTING
%  ========================================================================
function plot_position_speed_with_threshold(cp, session_name)
    % Creates a 1 or 2 panel plot showing X, Y, Speed, and the locomotion threshold.
    
    % Debug: Check what fields exist in classification
    fprintf('    DEBUG - Session %s classification fields:\n', session_name);
    if isfield(cp, 'classification')
        classification_fields = fieldnames(cp.classification);
        fprintf('      Available fields: %s\n', strjoin(classification_fields, ', '));
        
        % Check specific threshold fields and their values
        if isfield(cp.classification, 'track_stability_thresh')
            fprintf('      track_stability_thresh: %.4f\n', cp.classification.track_stability_thresh);
        else
            fprintf('      track_stability_thresh: NOT FOUND\n');
        end
        
        if isfield(cp.classification, 'sleepbox_stability_thresh')
            fprintf('      sleepbox_stability_thresh: %.4f\n', cp.classification.sleepbox_stability_thresh);
        else
            fprintf('      sleepbox_stability_thresh: NOT FOUND\n');
        end
    else
        fprintf('      No classification field found!\n');
    end
    
    % Check if centimeter data exists to determine the plot layout
    has_cm_data = isfield(cp.binned, 'x_cm') && ~all(isnan(cp.binned.x_cm));
    
    figure('Name', session_name, 'Color', 'w', 'Position', [100, 100, 1200, (450 * (1+has_cm_data))]);
    
    if has_cm_data
        tiledlayout(2, 1, 'TileSpacing', 'compact');
    else
        tiledlayout(1, 1);
    end
    
    % --- Panel 1: Pixel Units ---
    ax1 = nexttile;
    hold(ax1, 'on');
    
    plot(ax1, cp.binned.time_inj_aligned_s, cp.binned.x_px, 'DisplayName', 'X Position (px)');
    plot(ax1, cp.binned.time_inj_aligned_s, cp.binned.y_px, 'DisplayName', 'Y Position (px)');
    plot(ax1, cp.binned.time_inj_aligned_s, cp.binned.speed_px_s, 'k', 'LineWidth', 1.5, 'DisplayName', 'Speed (px/s)');
    
    % Overlay the locomotion threshold if it exists
    if isfield(cp.classification, 'locomotion_threshold_px_s') && ~isnan(cp.classification.locomotion_threshold_px_s)
        thresh_px = cp.classification.locomotion_threshold_px_s;
        yline(ax1, thresh_px, '--r', 'LineWidth', 2, 'DisplayName', sprintf('Locomotion Threshold (%.2f px/s)', thresh_px));
    end

    % --- IMPROVED: Plot points below stability thresholds with better error handling ---
    max_stability_thresh_px = [];
    
    % Try to determine stability threshold from available fields
    if isfield(cp, 'classification')
        if isfield(cp.classification, 'track_stability_thresh') && isfield(cp.classification, 'sleepbox_stability_thresh')
            % Both thresholds available - use maximum
            max_stability_thresh_px = max(cp.classification.track_stability_thresh, cp.classification.sleepbox_stability_thresh);
            fprintf('      Using max of both thresholds: %.4f px/s\n', max_stability_thresh_px);
        elseif isfield(cp.classification, 'track_stability_thresh')
            % Only track threshold available
            max_stability_thresh_px = cp.classification.track_stability_thresh;
            fprintf('      Using only track threshold: %.4f px/s\n', max_stability_thresh_px);
        elseif isfield(cp.classification, 'sleepbox_stability_thresh')
            % Only sleepbox threshold available
            max_stability_thresh_px = cp.classification.sleepbox_stability_thresh;
            fprintf('      Using only sleepbox threshold: %.4f px/s\n', max_stability_thresh_px);
        else
            fprintf('      No stability thresholds found - skipping red dots\n');
        end
    else
        fprintf('      No classification field - skipping red dots\n');
    end
    
    % Plot red dots if we have a threshold
    if ~isempty(max_stability_thresh_px) && ~isnan(max_stability_thresh_px)
        % Find indices where speed is below this threshold
        is_below_thresh = cp.binned.speed_px_s < max_stability_thresh_px;
        num_below = sum(is_below_thresh);
        
        fprintf('      Found %d points below stability threshold\n', num_below);
        
        if num_below > 0
            % Plot these points as red dots
            plot(ax1, cp.binned.time_inj_aligned_s(is_below_thresh), cp.binned.speed_px_s(is_below_thresh), ...
                'r.', 'MarkerSize', 6, 'DisplayName', sprintf('Below Stability Thresh (n=%d)', num_below));
        end
        
        % Also add the stability threshold as a horizontal line
        yline(ax1, max_stability_thresh_px, '--g', 'LineWidth', 1.5, 'DisplayName', sprintf('Stability Threshold (%.2f px/s)', max_stability_thresh_px));
    end
    % --- END IMPROVED SECTION ---
    
    title(ax1, sprintf('%s: Position and Speed (Pixel Units)', session_name), 'Interpreter', 'none');
    xlabel(ax1, 'Time from Injection (s)');
    ylabel(ax1, 'Value (px or px/s)');
    legend(ax1, 'Location', 'best');
    grid on;
    
    % --- Panel 2: Centimeter Units (only if data exists) ---
    if has_cm_data
        ax2 = nexttile;
        hold(ax2, 'on');
        
        plot(ax2, cp.binned.time_inj_aligned_s, cp.binned.x_cm, 'DisplayName', 'X Position (cm)');
        plot(ax2, cp.binned.time_inj_aligned_s, cp.binned.y_cm, 'DisplayName', 'Y Position (cm)');
        plot(ax2, cp.binned.time_inj_aligned_s, cp.binned.speed_cm_s, 'k', 'LineWidth', 1.5, 'DisplayName', 'Speed (cm/s)');
        
        % Overlay the locomotion threshold, converted to cm/s
        if isfield(cp.classification, 'locomotion_threshold_px_s') && ~isnan(cp.classification.locomotion_threshold_px_s)
            thresh_px = cp.classification.locomotion_threshold_px_s;
            ratio = cp.cm_to_px_ratio;
            thresh_cm = thresh_px * ratio;
            yline(ax2, thresh_cm, '--r', 'LineWidth', 2, 'DisplayName', sprintf('Locomotion Threshold (%.2f cm/s)', thresh_cm));
        end

        % Apply same improved logic for cm units
        if ~isempty(max_stability_thresh_px) && ~isnan(max_stability_thresh_px)
            max_stability_thresh_cm = max_stability_thresh_px * cp.cm_to_px_ratio;
            
            % Find indices where speed is below this threshold
            is_below_thresh_cm = cp.binned.speed_cm_s < max_stability_thresh_cm;
            num_below_cm = sum(is_below_thresh_cm);
            
            if num_below_cm > 0
                % Plot these points as red dots
                plot(ax2, cp.binned.time_inj_aligned_s(is_below_thresh_cm), cp.binned.speed_cm_s(is_below_thresh_cm), ...
                    'r.', 'MarkerSize', 6, 'DisplayName', sprintf('Below Stability Thresh (n=%d)', num_below_cm));
            end
            
            % Add stability threshold line
            yline(ax2, max_stability_thresh_cm, '--g', 'LineWidth', 1.5, 'DisplayName', sprintf('Stability Threshold (%.2f cm/s)', max_stability_thresh_cm));
        end
        
        title(ax2, 'Position and Speed (Centimeter Units)');
        xlabel(ax2, 'Time from Injection (s)');
        ylabel(ax2, 'Value (cm or cm/s)');
        legend(ax2, 'Location', 'best');
        grid on;
    end
end

%%
%% =======================================================================
%  Batch: Spatial Stillness Diagnostic Plots for all Mixed (Sleepbox + Track)
%  - Scans PositionExtraction root for Mixed sessions
%  - Loads clean_position struct (tries different filenames just incase)
%  - Confirms ArenaType == 'Mixed (Sleepbox + Track)'
%  - Plots arena shapes + full XY + overlay of 'Still' points
% ========================================================================

clear; clc; close all;

% === 0) CONFIGURE ROOT PATHS (EDIT THESE TWO LINES IF NEEDED) ===========
data_root = 'C:\Users\abbim\OneDrive - University College London\Documents\MSc\ResearchProject\MATLAB\TetrodeAnalysis\RawBehaviouralAnalysis\PositionExtraction';

% Filenames to try (in this order) under each session folder:
candidate_files = { ...
    'position_final_cm.mat', ...
    'position_a_s_sc_inj_aligned.mat'};

% === 1) FIND ALL ANIMAL / SESSION FOLDERS ================================
d_anim = dir(data_root);
d_anim = d_anim([d_anim.isdir] & ~ismember({d_anim.name},{'.','..'}));

n_plotted = 0; n_skipped = 0;

for a = 1:numel(d_anim)
    animal = d_anim(a).name;
    p_animal = fullfile(data_root, animal);
    d_sess = dir(p_animal);
    d_sess = d_sess([d_sess.isdir] & ~ismember({d_sess.name},{'.','..'}));
    
    for s = 1:numel(d_sess)
        sess = d_sess(s).name;
        p_sess = fullfile(p_animal, sess);

        % --- 2) Pick the first existing candidate file
        in_path = '';
        for k = 1:numel(candidate_files)
            p_try = fullfile(p_sess, candidate_files{k});
            if exist(p_try,'file')
                in_path = p_try;
                break;
            end
        end
        if isempty(in_path)
            fprintf('[-] No clean_position file found in %s\n', p_sess);
            n_skipped = n_skipped + 1;
            continue;
        end

        % --- 3) Load clean_position
        S = load(in_path);
        if ~isfield(S,'clean_position')
            fprintf('[-] %s does not contain clean_position\n', in_path);
            n_skipped = n_skipped + 1;
            continue;
        end
        cp = S.clean_position;

        % --- 4) Check ArenaType
        if ~isfield(cp,'summary') || ~isfield(cp.summary,'ArenaType') ...
                || ~strcmp(cp.summary.ArenaType, 'Mixed (Sleepbox + Track)')
            fprintf('[.] Skipping non-Mixed session: %s/%s\n', animal, sess);
            n_skipped = n_skipped + 1;
            continue;
        end

        % --- 5) Coords presence check
        if ~isfield(cp,'coords') || ~all(isfield(cp.coords, {'track_outer_poly','track_inner_poly','sleep_circle'}))
            fprintf('[-] Missing coords in %s/%s — no plot.\n', animal, sess);
            n_skipped = n_skipped + 1;
            continue;
        end

        % --- 6) Choose XY source (binned preferred, else resampled, else native)
        x_pos = []; y_pos = [];
        if isfield(cp,'binned') && all(isfield(cp.binned, {'x_px','y_px'}))
            x_pos = cp.binned.x_px(:); y_pos = cp.binned.y_px(:);
        elseif isfield(cp,'resampled') && all(isfield(cp.resampled, {'x_px','y_px'}))
            x_pos = cp.resampled.x_px(:); y_pos = cp.resampled.y_px(:);
        else
            % fallback to raw clean_position timebase
            if all(isfield(cp, {'x_px','y_px'}))
                x_pos = cp.x_px(:); y_pos = cp.y_px(:);
            end
        end

        if isempty(x_pos) || isempty(y_pos)
            fprintf('[-] No XY found for %s/%s — no plot.\n', animal, sess);
            n_skipped = n_skipped + 1;
            continue;
        end

        % --- 7) Stillness mask (optional)
        is_still = [];
        if isfield(cp,'classification') && isfield(cp.classification,'is_still_integrated')
            is_still = logical(cp.classification.is_still_integrated(:));
            if numel(is_still) ~= numel(x_pos)
                % length mismatch: clamp to min length
                L = min(numel(is_still), numel(x_pos));
                is_still = is_still(1:L);
                x_pos = x_pos(1:L);
                y_pos = y_pos(1:L);
            end
        else
            % If missing, just show path and zones (no still overlay)
            is_still = false(size(x_pos));
        end

        % --- 8) Extract arena shapes
        track_outer_x = cp.coords.track_outer_poly(:,1);
        track_outer_y = cp.coords.track_outer_poly(:,2);
        track_inner_x = cp.coords.track_inner_poly(:,1);
        track_inner_y = cp.coords.track_inner_poly(:,2);
        circle_params = cp.coords.sleep_circle;  % [cx, cy, r]
        cx = circle_params(1); cy = circle_params(2); r = circle_params(3);
        th = linspace(0,2*pi,100);
        x_circ = r*cos(th)+cx;  y_circ = r*sin(th)+cy;

        % --- 9) PLOT
        f = figure('Name', sprintf('Spatial Stillness: %s/%s', animal, sess), ...
                   'Color','w','Position',[100 100 980 880]);
        ax = axes(f); hold(ax,'on');

        % background zones
        patch(ax, track_outer_x, track_outer_y, [0.8 0.9 1], 'FaceAlpha', 0.5, ...
              'EdgeColor', 'none', 'DisplayName', 'Track Zone');
        patch(ax, track_inner_x, track_inner_y, 'w', 'FaceAlpha', 1, ...
              'EdgeColor', 'none', 'HandleVisibility','off');
        patch(ax, x_circ, y_circ, [1 0.8 0.8], 'FaceAlpha', 0.5, ...
              'EdgeColor', 'none', 'DisplayName', 'Sleepbox Zone');

        % full path
        plot(ax, x_pos, y_pos, '.', 'Color',[0.7 0.7 0.7], 'MarkerSize', 5, ...
             'DisplayName','All Data Points');

        % still overlay (only if any)
        if any(is_still)
            idxS = find(is_still);
            plot(ax, x_pos(idxS), y_pos(idxS), 'o', ...
                'MarkerEdgeColor','k', ...
                'MarkerFaceColor',[0.91, 0.41, 0.17], ...
                'MarkerSize', 5, ...
                'DisplayName','Still Points');
        end

        % aesthetics
        title(ax, sprintf('Spatial Stillness Classification: %s', strrep(sess,'_','\_')));
        xlabel(ax,'X Position (pixels)'); ylabel(ax,'Y Position (pixels)');
        axis(ax,'equal'); axis(ax,'tight'); grid(ax,'on'); box(ax,'on');
        set(ax,'YDir','reverse');
        legend(ax,'Location','best');
    end
end

fprintf('\nDone. Plotted %d sessions, skipped %d.\n', n_plotted, n_skipped);


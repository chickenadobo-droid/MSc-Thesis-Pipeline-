%% ================================================================================
%% TIME WINDOW ANALYSIS GLM 
%% ================================================================================

fprintf('\n================================================================\n');
fprintf('TIME WINDOW ANALYSIs\n');
fprintf('================================================================\n\n');

clc; clear all; close all;

%% Helper function to sanitise window names for field names
function field_name = sanitize_window_name(window_name)
    % Convert window name to valid MATLAB field name
    field_name = window_name;
    
    % Replace spaces with underscores
    field_name = strrep(field_name, ' ', '_');
    
    % Replace hyphens with 'to'
    field_name = strrep(field_name, '-', 'to');
    
    % Remove 'to' text (from "181 to 360")
    field_name = strrep(field_name, '_to_', 'to');
    
    % If starts with number, add 'W' prefix (Window)
    if ~isempty(field_name) && isstrprop(field_name(1), 'digit')
        field_name = ['W' field_name];
    end
end

%% ================================================================================
%% STEP 1: LOAD & CLEAN DATA
%% ================================================================================
fprintf('STEP 1: Loading and Cleaning Data...\n');
fprintf('--------------------------------------\n');

table_path = 'C:\Users\abbim\OneDrive - University College London\Documents\MSc\ResearchProject\MATLAB\TetrodeAnalysis';
output_path = fullfile(table_path, 'FinalAnalysis_Clean');
if ~exist(output_path, 'dir'), mkdir(output_path); end

load(fullfile(table_path, 'Final_Table_for_GLM_cleanMUA_NewZ.mat'), 'Final_GLM_Table');
fprintf('  Loaded: Final_Table_for_GLM_cleanMUA_NewZ.mat (%d rows)\n', height(Final_GLM_Table));

% Remove missing locations
valid_mask = ~ismissing(Final_GLM_Table.Location);
T = Final_GLM_Table(valid_mask, :);
fprintf('  Rows after removing missing locations: %d\n', height(T));

% Remove Contaminated Sessions
contaminated_sessions = {
    'mouseB6_CNO_Day2_Sleep_11_26_2012';
    'mouseD12_050213_Day6_PBS';
    'mouseD12_050913_Day7_CNO'
};

contaminated_mask = ismember(T.SessionName, contaminated_sessions);
if any(contaminated_mask)
    fprintf('  Removing %d contaminated session(s)\n', sum(contaminated_mask));
    T = T(~contaminated_mask, :);
end

time_limit_mask = T.time_min <= 360;
T = T(time_limit_mask, :);
fprintf('  Limiting data to ≤360 minutes post-injection\n');

fprintf('\nCLEANING COMPLETE\n');
fprintf('  Final Rows: %d\n', height(T));
fprintf('  Final Sessions: %d\n', length(unique(T.SessionName)));
fprintf('  Final Animals: %d\n\n', length(unique(T.AnimalID)));

T_clean = T;
clear T Final_GLM_Table;


%% ================================================================================
%% STEP 2: NORMALIZE TO BASELINE
%% ================================================================================
fprintf('================================================================\n');
fprintf('STEP 2: Z-Scoring to Pre-Injection Baseline\n');
fprintf('================================================================\n\n');

raw_mua_col = 'MUA_mean_Hz_replicated';
raw_theta_col = 'theta_power_mean_corrected';
raw_ripple_col = 'ripple_power_mean';
raw_theta_freq_col = 'theta_freq_weighted_mean_corrected'; 
raw_ripple_events_col = 'ripple_events'; 

unique_sessions = unique(T_clean.SessionName);

T_clean.MUA_Z_Baseline = NaN(height(T_clean), 1);
T_clean.Theta_Z_Baseline = NaN(height(T_clean), 1);
T_clean.Ripple_Z_Baseline = NaN(height(T_clean), 1);
T_clean.Theta_Freq_Z_Baseline = NaN(height(T_clean), 1); 
T_clean.Ripple_Events_Z_Baseline = NaN(height(T_clean), 1); 

for s = 1:length(unique_sessions)
    session = unique_sessions{s};
    session_mask = strcmp(T_clean.SessionName, session);
    pre_inj_mask = session_mask & T_clean.time_min < 0;
    
    % Z-Score each metric
    metrics = {raw_mua_col, raw_theta_col, raw_ripple_col, raw_theta_freq_col, raw_ripple_events_col};
    z_cols = {'MUA_Z_Baseline', 'Theta_Z_Baseline', 'Ripple_Z_Baseline', 'Theta_Freq_Z_Baseline', 'Ripple_Events_Z_Baseline'};
    
    for m = 1:length(metrics)
        pre_data = T_clean.(metrics{m})(pre_inj_mask);
        if sum(pre_inj_mask) > 0
            mean_val = mean(pre_data, 'omitnan');
            std_val = std(pre_data, 'omitnan');
            if std_val > 0
                T_clean.(z_cols{m})(session_mask) = (T_clean.(metrics{m})(session_mask) - mean_val) / std_val;
            else
                T_clean.(z_cols{m})(session_mask) = 0;
            end
        end
    end
end

fprintf('Normalisation complete\n\n');

%% ================================================================================
%% STEP 2.5: DEFINE BEHAVIOURAL STATES AND METRICS
%% ================================================================================
fprintf('================================================================\n');
fprintf('STEP 2.5: Defining Behavioural States\n');
fprintf('================================================================\n\n');

active_states = {'Moving'};
quiescent_states = {'Still', 'Sleep'};

T_clean.BehaviouralGroup = repmat(categorical(missing), height(T_clean), 1);
for i = 1:height(T_clean)
    state = T_clean.BehaviouralState{i};
    if contains(state, '+')
        T_clean.BehaviouralGroup(i) = categorical(missing);
    elseif any(strcmp(state, active_states))
        T_clean.BehaviouralGroup(i) = 'Active';
    elseif any(strcmp(state, quiescent_states))
        T_clean.BehaviouralGroup(i) = 'Quiescent';
    end
end
T_clean = T_clean(~ismissing(T_clean.BehaviouralGroup), :);

% Report breakdown
n_active = sum(T_clean.BehaviouralGroup == 'Active');
n_quiescent = sum(T_clean.BehaviouralGroup == 'Quiescent');
fprintf('  Behavioural state breakdown:\n');
fprintf('    Active (Moving): %d rows (%.1f%%)\n', n_active, 100*n_active/height(T_clean));
fprintf('    Quiescent (Still + Sleep): %d rows (%.1f%%)\n', n_quiescent, 100*n_quiescent/height(T_clean));
fprintf('  Final rows: %d\n\n', height(T_clean));

% Define metrics to analyse
metrics_to_test = {
    'MUA_Z_Baseline', 'Multi-Unit Activity';
    'Theta_Z_Baseline', 'Theta Power';
    'Ripple_Z_Baseline', 'Ripple Power';
    'Theta_Freq_Z_Baseline', 'Theta Frequency';
    'Ripple_Events_Z_Baseline', 'Ripple Events';
    'speed_z_px_s', 'Animal Speed'; 
};

time_windows = {
    'Pre-Injection',       -100, 0;      % Pre-injection baseline (REFERENCE)
    '0-1hr',        0, 60;     % Acute phase
    '1-2hr',       60, 180;    % Intermediate phase  
    '2-5hr',      180, 360;    % Late phase
};

% Define behavioural states to analyse
states_to_test = {
    true(height(T_clean), 1), 'All_States';
    T_clean.BehaviouralGroup == 'Active', 'Active_Moving';
    T_clean.BehaviouralGroup == 'Quiescent', 'Quiescent_Still_Sleep'
};

% Define colors
color_cno = [0.8500, 0.3250, 0.0980];
color_veh = [0, 0.4470, 0.7410];

% Calculate global y-axis limits
fprintf('Calculating global y-axis limits...\n');
all_data_values = [];
for m = 1:size(metrics_to_test, 1)
    metric_var = metrics_to_test{m, 1};
    all_data_values = [all_data_values; T_clean.(metric_var)];
end
p_low = prctile(all_data_values, 1);
p_high = prctile(all_data_values, 99);
data_range = p_high - p_low;
padding = data_range * 0.1;
global_ylim = [p_low - padding, p_high + padding];
fprintf('  Global Y-limit: [%.2f, %.2f]\n\n', global_ylim(1), global_ylim(2));

fprintf('Time windows defined:\n');
for w = 1:size(time_windows, 1)
    fprintf('  %s: %d to %d minutes\n', time_windows{w,1}, time_windows{w,2}, time_windows{w,3});
end
fprintf('\n');

% Create output structure
window_results = struct();

%% ================================================================================
%% STEP 3: FIT MIXED-EFFECTS MODELS
%% ================================================================================
fprintf('================================================================\n');
fprintf('STEP 3: Fitting Mixed-Effects Models\n');
fprintf('================================================================\n\n');

%% Loop through states
for s = 1:size(states_to_test, 1)
    state_mask = states_to_test{s, 1};
    state_name = states_to_test{s, 2};
    state_field = state_name;
    
    fprintf('Analyzing state: %s\n', state_name);
    window_results.(state_field) = struct();
    
    %% Loop through metrics
    for m = 1:size(metrics_to_test, 1)
        metric_var = metrics_to_test{m, 1};
        metric_name = metrics_to_test{m, 2};
        
        fprintf('  Processing: %s\n', metric_name);
        
        % Get data subset
        data_subset = T_clean(state_mask, :);
        valid_data = ~isnan(data_subset.(metric_var));
        data_subset = data_subset(valid_data, :);
        
        if height(data_subset) < 20
            fprintf('    Insufficient data (n=%d)\n', height(data_subset));
            continue;
        end
        
        % Assign time windows
        data_subset.TimeWindow = categorical(repmat({'Unknown'}, height(data_subset), 1));
        
        for w = 1:size(time_windows, 1)
            window_name = time_windows{w, 1};
            t_start = time_windows{w, 2};
            t_end = time_windows{w, 3};
            
            mask = data_subset.time_min >= t_start & data_subset.time_min <= t_end;
            data_subset.TimeWindow(mask) = categorical({window_name});
        end
        
        % Remove any data outside defined windows
        data_subset = data_subset(data_subset.TimeWindow ~= 'Unknown', :);
        
        if height(data_subset) < 20
            fprintf('    Insufficient data after window assignment (n=%d)\n', height(data_subset));
            continue;
        end
        
        % Remove "Unknown" from categories AND get actual existing categories
        data_subset.TimeWindow = removecats(data_subset.TimeWindow, 'Unknown');
        existing_categories = categories(data_subset.TimeWindow);
        
        % Create desired order based on time_windows definition
        desired_order = time_windows(:, 1);
        
        % Build valid order: only categories that exist, in desired order
        valid_order = {};
        for i = 1:length(desired_order)
            if any(strcmp(desired_order{i}, existing_categories))
                valid_order{end+1} = desired_order{i};
            end
        end
        
        if isempty(valid_order) || length(valid_order) < 2
            fprintf('    Insufficient time windows with data (only %d windows)\n', length(valid_order));
            continue;
        end
        
        % **CHANGED: REFERENCE CODING - Pre first, Vehicle as reference**
        data_subset.TimeWindow = reordercats(data_subset.TimeWindow, valid_order);
        data_subset.Condition = reordercats(data_subset.Condition, {'Vehicle', 'CNO'});
        
        % Check sample sizes per window
        fprintf('    Sample sizes per window:\n');
        for w = 1:length(valid_order)
            window_name = valid_order{w};
            n_samples = sum(data_subset.TimeWindow == window_name);
            fprintf('      %s: n=%d\n', window_name, n_samples);
        end

        %% Fit mixed-effects model with REFERENCE coding
        formula = sprintf('%s ~ Condition * TimeWindow + (1|AnimalID) + (1|SessionName)', metric_var);
        
        try
            glme = fitglme(data_subset, formula, 'Distribution', 'Normal', ...
                'DummyVarCoding', 'reference');  % **CHANGED: reference coding**
            
            fprintf('    Model fit successful\n');
            
            % Store model and data
            window_results.(state_field).(metric_var).model = glme;
            window_results.(state_field).(metric_var).data = data_subset;
            
            % Extract coefficients
            coef_table = glme.Coefficients;
            names = coef_table.Name;
            pvals = coef_table.pValue;
            estimates = coef_table.Estimate;
            se = coef_table.SE;
            
            % DEBUG: Print first model's coefficients
            if s == 1 && m == 1
                fprintf('\n    DEBUG - Coefficient names in model:\n');
                for i = 1:length(names)
                    fprintf('      %d: %s (p=%.4f)\n', i, names{i}, pvals(i));
                end
                fprintf('\n');
            end
            
            fprintf('    Fixed effects:\n');
            
            % Find interaction terms
            interaction_idx = false(size(names));
            for i = 1:length(names)
                if contains(names{i}, ':TimeWindow') || contains(names{i}, 'TimeWindow_') && contains(names{i}, ':Condition')
                    interaction_idx(i) = true;
                end
            end
            
            if any(interaction_idx)
                fprintf('      Condition × TimeWindow interactions:\n');
                interaction_names = names(interaction_idx);
                interaction_pvals = pvals(interaction_idx);
                
                for i = 1:length(interaction_names)
                    effect_name = interaction_names{i};
                    p_val = interaction_pvals(i);
                    
                    if p_val < 0.001
                        sig_str = '***';
                    elseif p_val < 0.01
                        sig_str = '**';
                    elseif p_val < 0.05
                        sig_str = '*';
                    else
                        sig_str = 'ns';
                    end
                    
                    fprintf('        %s: p=%.4f %s\n', effect_name, p_val, sig_str);
                end
            end
            
            % Store p-values
            window_results.(state_field).(metric_var).coefficient_names = names;
            window_results.(state_field).(metric_var).pvalues = pvals;
            window_results.(state_field).(metric_var).estimates = estimates;
            window_results.(state_field).(metric_var).se = se;
            
        catch ME
            fprintf('    ✗ Model fitting failed: %s\n', ME.message);
            if ~isempty(ME.stack)
                fprintf('       Stack: %s (line %d)\n', ME.stack(1).name, ME.stack(1).line);
            end
            continue;
        end
    end
    
    fprintf('\n');
end

%% ================================================================================
%% STEP 4: POST-HOC CONTRASTS WITH BONFERRONI-HOLM CORRECTION
%% ================================================================================

fprintf('\n================================================================\n');
fprintf('STEP 4: POST-HOC CONTRASTS - CNO vs Vehicle within each time window\n');
fprintf('        WITH BONFERRONI-HOLM SEQUENTIAL CORRECTION\n');
fprintf('================================================================\n\n');

contrast_results = struct();

% **CHANGED: Collect all p-values across all models for Bonferroni-Holm**
all_pvalues = [];
all_test_info = {};

for s = 1:size(states_to_test, 1)
    state_mask = states_to_test{s, 1};
    state_name = states_to_test{s, 2};
    state_field = state_name;
    
    for m = 1:size(metrics_to_test, 1)
        metric_var = metrics_to_test{m, 1};
        metric_name = metrics_to_test{m, 2};
        
        % Check if model exists for this metric
        if ~isfield(window_results.(state_field), metric_var)
            continue;
        end
        
        glme = window_results.(state_field).(metric_var).model;
        data_subset = window_results.(state_field).(metric_var).data;
        coef_names = window_results.(state_field).(metric_var).coefficient_names;
        coef_pvals = window_results.(state_field).(metric_var).pvalues;
        
        % Get the actual windows present in this dataset
        existing_windows = categories(data_subset.TimeWindow);
        
        % **CHANGED: Only test POST-INJECTION windows (exclude Pre)**
        post_injection_windows = existing_windows(~strcmp(existing_windows, 'Pre'));
        
        % Loop through post-injection windows and collect p-values
        for w = 1:length(post_injection_windows)
            window_name = post_injection_windows{w};
            
            % Find the interaction term for this window
            possible_names = {
                sprintf('Condition_CNO:TimeWindow_%s', window_name);
                sprintf('TimeWindow_%s:Condition_CNO', window_name);
                sprintf('Condition_CNO:TimeWindow_%s', strrep(window_name, ' ', '_'));
                sprintf('Condition_CNO:TimeWindow_%s', strrep(window_name, '-', '_'));
            };
            
            term_idx = false(size(coef_names));
            for name_try = 1:length(possible_names)
                term_idx = strcmp(coef_names, possible_names{name_try});
                if any(term_idx)
                    break;
                end
            end
            
            if any(term_idx)
                p_val = coef_pvals(term_idx);
                all_pvalues = [all_pvalues; p_val];
                all_test_info{end+1} = struct('state', state_field, 'metric', metric_var, ...
                    'window', window_name, 'term_idx', term_idx);
            end
        end
    end
end

% Apply Bonferroni-Holm correction
n_tests = length(all_pvalues);
[sorted_pvals, sort_idx] = sort(all_pvalues);
holm_significant = false(n_tests, 1);

fprintf('Applying Bonferroni-Holm sequential correction:\n');
fprintf('  Total tests: %d\n', n_tests);
fprintf('  Family-wise alpha: 0.05\n\n');

for i = 1:n_tests
    adjusted_alpha = 0.05 / (n_tests - i + 1);
    if sorted_pvals(i) <= adjusted_alpha
        holm_significant(sort_idx(i)) = true;
        fprintf('  Test %d/%d: p=%.4f <= α=%.4f ✓ Significant\n', i, n_tests, sorted_pvals(i), adjusted_alpha);
    else
        fprintf('  Test %d/%d: p=%.4f > α=%.4f ✗ Stop testing\n', i, n_tests, sorted_pvals(i), adjusted_alpha);
        break;
    end
end

fprintf('\n');

% **CHANGED: Now loop through and store results with Holm correction**
test_counter = 0;

for s = 1:size(states_to_test, 1)
    state_mask = states_to_test{s, 1};
    state_name = states_to_test{s, 2};
    state_field = state_name;
    
    fprintf('State: %s\n', state_name);
    contrast_results.(state_field) = struct();
    
    for m = 1:size(metrics_to_test, 1)
        metric_var = metrics_to_test{m, 1};
        metric_name = metrics_to_test{m, 2};
        
        if ~isfield(window_results.(state_field), metric_var)
            continue;
        end
        
        fprintf('  Metric: %s\n', metric_name);
        
        glme = window_results.(state_field).(metric_var).model;
        data_subset = window_results.(state_field).(metric_var).data;
        coef_names = window_results.(state_field).(metric_var).coefficient_names;
        coef_pvals = window_results.(state_field).(metric_var).pvalues;
        coef_estimates = window_results.(state_field).(metric_var).estimates;
        
        existing_windows = categories(data_subset.TimeWindow);
        contrast_results.(state_field).(metric_var) = struct();
        
        post_injection_windows = existing_windows(~strcmp(existing_windows, 'Pre-Injection'));
        
        fprintf('    Contrasts:\n');
        
        for w = 1:length(post_injection_windows)
            window_name = post_injection_windows{w};
            test_counter = test_counter + 1;
            
            % Find window boundaries
            window_idx = find(strcmp(time_windows(:,1), window_name));
            if isempty(window_idx)
                fprintf('      %s: Could not find window definition\n', window_name);
                continue;
            end
            
            t_start = time_windows{window_idx, 2};
            t_end = time_windows{window_idx, 3};
            t_center = mean([t_start, t_end]);
            
            % Create prediction tables
            pred_veh = table();
            pred_veh.Condition = categorical({'Vehicle'}, {'Vehicle', 'CNO'});
            pred_veh.TimeWindow = categorical({window_name}, existing_windows);
            pred_veh.time_min = t_center;
            pred_veh.AnimalID = data_subset.AnimalID(1);
            pred_veh.SessionName = data_subset.SessionName(1);
            
            pred_cno = pred_veh;
            pred_cno.Condition = categorical({'CNO'}, {'Vehicle', 'CNO'});
            
            try
                pred_val_veh = predict(glme, pred_veh, 'Conditional', false);
                pred_val_cno = predict(glme, pred_cno, 'Conditional', false);
                
                diff_estimate = pred_val_cno - pred_val_veh;
                
                % Find the interaction term
                possible_names = {
                    sprintf('Condition_CNO:TimeWindow_%s', window_name);
                    sprintf('TimeWindow_%s:Condition_CNO', window_name);
                    sprintf('Condition_CNO:TimeWindow_%s', strrep(window_name, ' ', '_'));
                    sprintf('Condition_CNO:TimeWindow_%s', strrep(window_name, '-', '_'));
                };
                
                term_idx = false(size(coef_names));
                for name_try = 1:length(possible_names)
                    term_idx = strcmp(coef_names, possible_names{name_try});
                    if any(term_idx)
                        break;
                    end
                end
                
                if any(term_idx)
                    p_val = coef_pvals(term_idx);
                    se_val = window_results.(state_field).(metric_var).se(term_idx);
                else
                    p_val = NaN;
                    se_val = NaN;
                    fprintf('      WARNING: Could not find interaction term for %s\n', window_name);
                end
                
                % Apply Holm significance
                is_significant = holm_significant(test_counter);
                
                % Determine significance string - grade stars based on corrected significance thresholds
                if is_significant
                    % Use the Holm-adjusted alpha that this test passed
                    test_rank = find(sort_idx == test_counter);
                    adjusted_alpha = 0.05 / (n_tests - test_rank + 1);
                    
                    if adjusted_alpha <= 0.001 / n_tests
                        sig_str = '***';
                    elseif adjusted_alpha <= 0.01 / n_tests
                        sig_str = '**';
                    else
                        sig_str = '*';
                    end
                else
                    sig_str = 'ns';
                end

                fprintf('      %s: CNO-Vehicle = %.3f, p=%.4f %s (Holm-corrected)\n', ...
                    window_name, diff_estimate, p_val, sig_str);
                
                % Store results
                window_field = sanitize_window_name(window_name);
                
                contrast_results.(state_field).(metric_var).(window_field).estimate = diff_estimate;
                contrast_results.(state_field).(metric_var).(window_field).p_value = p_val;
                contrast_results.(state_field).(metric_var).(window_field).p_value_uncorrected = p_val;
                contrast_results.(state_field).(metric_var).(window_field).significant = is_significant;
                contrast_results.(state_field).(metric_var).(window_field).window_name = window_name;
                contrast_results.(state_field).(metric_var).(window_field).se = se_val;
                contrast_results.(state_field).(metric_var).(window_field).n_tests_total = n_tests;
                
            catch ME
                fprintf('      %s: Failed - %s\n', window_name, ME.message);
            end
        end
        
        fprintf('\n');
    end
end

%% Save results
save(fullfile(output_path, 'TimeWindowAnalysis_Results.mat'), ...
    'window_results', 'contrast_results', 'time_windows', 'states_to_test');

fprintf('================================================================\n');
fprintf('TIME WINDOW ANALYSIS COMPLETE\n');
fprintf('Results saved to: TimeWindowAnalysis_Results.mat\n');
fprintf('================================================================\n\n');


%% ================================================================================
%% STEP 5: VISUALISATIONS WITH CATEGORICAL TIME WINDOWS
%% ================================================================================
close all; 

fprintf('Creating visualizations with categorical time windows...\n\n');

viz_path = fullfile(output_path, 'TimeWindowPlots');
if ~exist(viz_path, 'dir'), mkdir(viz_path); end

% Define better metric titles for display
metric_display_names = containers.Map(...
    {'MUA_Z_Baseline', 'Theta_Z_Baseline', 'Ripple_Z_Baseline', 'Theta_Freq_Z_Baseline', 'Ripple_Events_Z_Baseline', 'speed_z_px_s'}, ...
    {'Multi-Unit Activity', 'Theta Power', 'Ripple Power', 'Theta Frequency', 'Ripple Events', 'Animal Speed'});

for s = 1:size(states_to_test, 1)
    state_mask = states_to_test{s, 1};
    state_name = states_to_test{s, 2};
    state_field = state_name;

    fprintf('Creating plots for: %s\n', state_name);

    fig = figure('Position', [100, 100, 1800, 1000], 'Color', 'w');
    tl = tiledlayout(2, 3, 'TileSpacing', 'compact', 'Padding', 'compact');

    for m = 1:size(metrics_to_test, 1)
        metric_var = metrics_to_test{m, 1};
        metric_name = metrics_to_test{m, 2};

        % Use better display name if available
        if isKey(metric_display_names, metric_var)
            display_metric_name = metric_display_names(metric_var);
        else
            display_metric_name = metric_name;
        end

        nexttile(tl);
        hold on;

        % Get data
        data_subset = T_clean(state_mask, :);
        valid_data = ~isnan(data_subset.(metric_var));
        data_subset = data_subset(valid_data, :);

        if height(data_subset) < 10
            title(sprintf('%s\n(Insufficient data)', display_metric_name), 'FontSize', 12);
            ylim([-5, 5]);
            continue;
        end

        % Assign time windows to data
        data_subset.TimeWindow = categorical(repmat({'Unknown'}, height(data_subset), 1));
        for w = 1:size(time_windows, 1)
            window_name = time_windows{w, 1};
            t_start = time_windows{w, 2};
            t_end = time_windows{w, 3};
            mask = data_subset.time_min >= t_start & data_subset.time_min <= t_end;
            data_subset.TimeWindow(mask) = categorical({window_name});
        end
        
        % Remove unknown windows
        data_subset = data_subset(data_subset.TimeWindow ~= 'Unknown', :);
        data_subset.TimeWindow = removecats(data_subset.TimeWindow, 'Unknown');
        
        % Get existing windows in order
        existing_windows = {};
        for w = 1:size(time_windows, 1)
            if any(data_subset.TimeWindow == time_windows{w, 1})
                existing_windows{end+1} = time_windows{w, 1};
            end
        end
        
        if isempty(existing_windows)
            title(sprintf('%s\n(No windowed data)', display_metric_name), 'FontSize', 12);
            ylim([-5, 5]);
            continue;
        end
        
        % Reorder categories
        data_subset.TimeWindow = reordercats(data_subset.TimeWindow, existing_windows);
        
        % Create numeric x positions for each window
        window_positions = 1:length(existing_windows);
        window_width = 0.8;
        
        % Plot data points with jitter within each window
        for w = 1:length(existing_windows)
            window_name = existing_windows{w};
            
            % CNO data in this window
            cno_mask = data_subset.Condition == 'CNO' & data_subset.TimeWindow == window_name;
            if any(cno_mask)
                cno_vals = data_subset.(metric_var)(cno_mask);
                n_cno = length(cno_vals);
                x_jitter = window_positions(w) + (rand(n_cno, 1) - 0.5) * window_width * 0.4 - 0.15;
                scatter(x_jitter, cno_vals, 15, color_cno, 'filled', ...
                    'MarkerFaceAlpha', 0.3, 'HandleVisibility', ternary(w==1, 'on', 'off'), ...
                    'DisplayName', 'CNO data');
            end
            
            % Vehicle data in this window
            veh_mask = data_subset.Condition == 'Vehicle' & data_subset.TimeWindow == window_name;
            if any(veh_mask)
                veh_vals = data_subset.(metric_var)(veh_mask);
                n_veh = length(veh_vals);
                x_jitter = window_positions(w) + (rand(n_veh, 1) - 0.5) * window_width * 0.4 + 0.15;
                scatter(x_jitter, veh_vals, 15, color_veh, 'filled', ...
                    'MarkerFaceAlpha', 0.3, 'HandleVisibility', ternary(w==1, 'on', 'off'), ...
                    'DisplayName', 'Vehicle data');
            end
        end
        
        % OVERLAY MODEL PREDICTIONS WITH 95% CI
        if isfield(window_results.(state_field), metric_var)
            glme = window_results.(state_field).(metric_var).model;
            data_with_windows = window_results.(state_field).(metric_var).data;
            model_windows = categories(data_with_windows.TimeWindow);
            
            pred_x_veh = [];
            pred_y_veh = [];
            pred_ci_lower_veh = [];
            pred_ci_upper_veh = [];
            
            pred_x_cno = [];
            pred_y_cno = [];
            pred_ci_lower_cno = [];
            pred_ci_upper_cno = [];
            
            for w = 1:length(existing_windows)
                window_name = existing_windows{w};
                
                if ~ismember(window_name, model_windows)
                    continue;
                end
                
                window_idx = find(strcmp(time_windows(:,1), window_name));
                t_start = time_windows{window_idx, 2};
                t_end = time_windows{window_idx, 3};
                t_center = mean([t_start, t_end]);
                
                pred_veh = table();
                pred_veh.Condition = categorical({'Vehicle'}, {'Vehicle', 'CNO'});
                pred_veh.TimeWindow = categorical({window_name}, model_windows);
                pred_veh.time_min = t_center;
                pred_veh.AnimalID = data_subset.AnimalID(1);
                pred_veh.SessionName = data_subset.SessionName(1);
                
                pred_cno = pred_veh;
                pred_cno.Condition = categorical({'CNO'}, {'Vehicle', 'CNO'});
                
                try
                    [y_veh, ci_veh] = predict(glme, pred_veh, 'Conditional', false, 'Alpha', 0.05);
                    [y_cno, ci_cno] = predict(glme, pred_cno, 'Conditional', false, 'Alpha', 0.05);
                    
                    pred_x_veh = [pred_x_veh; window_positions(w)];
                    pred_y_veh = [pred_y_veh; y_veh];
                    pred_ci_lower_veh = [pred_ci_lower_veh; ci_veh(1)];
                    pred_ci_upper_veh = [pred_ci_upper_veh; ci_veh(2)];
                    
                    pred_x_cno = [pred_x_cno; window_positions(w)];
                    pred_y_cno = [pred_y_cno; y_cno];
                    pred_ci_lower_cno = [pred_ci_lower_cno; ci_cno(1)];
                    pred_ci_upper_cno = [pred_ci_upper_cno; ci_cno(2)];
                catch ME
                    continue;
                end
            end
            
            if ~isempty(pred_x_veh)
                errorbar(pred_x_veh + 0.15, pred_y_veh, ...
                    pred_y_veh - pred_ci_lower_veh, pred_ci_upper_veh - pred_y_veh, ...
                    'o-', 'Color', color_veh, 'LineWidth', 2.5, 'MarkerSize', 8, ...
                    'MarkerFaceColor', color_veh, 'DisplayName', 'Vehicle model', ...
                    'CapSize', 6);
                
                errorbar(pred_x_cno - 0.15, pred_y_cno, ...
                    pred_y_cno - pred_ci_lower_cno, pred_ci_upper_cno - pred_y_cno, ...
                    'o-', 'Color', color_cno, 'LineWidth', 2.5, 'MarkerSize', 8, ...
                    'MarkerFaceColor', color_cno, 'DisplayName', 'CNO model', ...
                    'CapSize', 6);
            end
        end
        
        % Add vertical separators between windows
        for w = 1:length(existing_windows)-1
            xline(window_positions(w) + 0.5, ':', 'Color', [0.7 0.7 0.7], ...
                'LineWidth', 1.5, 'HandleVisibility', 'off');
        end
        
        % Set title and INITIAL limits
        title(display_metric_name, 'FontSize', 12, 'FontWeight', 'bold');
        
        % Individual y-axis per metric
        metric_data = data_subset.(metric_var);
        ylim_low = prctile(metric_data, 0.5);
        ylim_high = prctile(metric_data, 99.5);
        padding = (ylim_high - ylim_low) * 0.15;
        ylim([ylim_low - padding, ylim_high + padding]);
        
        % **CHANGED: Add significance stars AFTER ylim is set, only for POST-INJECTION bins**
        if isfield(contrast_results.(state_field), metric_var)
            current_ylim = ylim;
            y_pos = current_ylim(2) * 0.88;
            
            tested_window_fields = fieldnames(contrast_results.(state_field).(metric_var));
            
            for w = 1:length(tested_window_fields)
                window_field = tested_window_fields{w};
                result_struct = contrast_results.(state_field).(metric_var).(window_field);
                
                % Only show stars for post-injection windows
                if strcmp(result_struct.window_name, 'Pre-Injection')
                    continue;  % Skip Pre bin
                end
                
                if result_struct.significant
                    window_name = result_struct.window_name;
                    
                    window_pos_idx = find(strcmp(existing_windows, window_name));
                    if ~isempty(window_pos_idx)
                        p_val = result_struct.p_value;
                        
                        % Star grading based on UNCORRECTED p-value
                        if p_val < 0.001
                            star_text = '***';
                        elseif p_val < 0.01
                            star_text = '**';
                        else
                            star_text = '*';
                        end
                        
                        if ~isempty(star_text)
                            text(window_positions(window_pos_idx), y_pos, star_text, ...
                                'FontSize', 16, 'HorizontalAlignment', 'center', ...
                                'FontWeight', 'bold', 'Color', 'k');
                        end
                    end
                end
            end
        end
        
        % Format x-axis
        xticks(window_positions);
        xticklabels(existing_windows);
        xtickangle(45);
        xlim([0.5, length(existing_windows) + 0.5]);
        grid on;
        box on;
    end

    % Add shared Y label
    ylabel(tl, 'Z-Score', 'FontSize', 12, 'FontWeight', 'bold');
    xlabel(tl, 'Time Window', 'FontSize', 12, 'FontWeight', 'bold');

    % Create legend
    lgd = legend(tl.Children(end), 'Location', 'northoutside', ...
        'Orientation', 'horizontal', 'FontSize', 9);
    lgd.Layout.Tile = 'north';

    % Use nice display name for title
    display_name = strrep(state_name, '_', ' ');
    display_name = strrep(display_name, 'Quiescent Still Sleep', 'Behavioural Quiescence (Still/Sleep)');
    display_name = strrep(display_name, 'Active Moving', 'Active Movement');
    title(tl, sprintf('Time Window Analysis of CNO Effect for %s', display_name), ...
        'FontSize', 16, 'FontWeight', 'bold');

    filename = sprintf('TimeWindows_%s_Categorical.png', state_field);
    saveas(fig, fullfile(viz_path, filename));
    fprintf('  ✓ Saved: %s\n', filename);
end

fprintf('\nVisualization complete!\n');
fprintf('\n================================================================\n');
fprintf('ANALYSIS COMPLETE - All results include Bonferroni-Holm correction\n');
fprintf('================================================================\n');

% Helper function for ternary operator
function result = ternary(condition, true_val, false_val)
    if condition
        result = true_val;
    else
        result = false_val;
    end
end
